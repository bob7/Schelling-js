<!DOCTYPE html>
<html>
<head>
<title>Schelling 2D Animation (JavaScript)</title>
<style>
  body { margin: 0; overflow: hidden; background:#222; display: flex; }
  #controls {
    width: 280px; 
    padding: 20px;
    color: #eee;
    display: flex;
    flex-direction: column;
    gap: 15px; /* Slightly reduced gap */
    margin-left: 80px; /* Adjusted margin */
    margin-top: 200px; /* Adjusted margin */
  }
  #controls label {
    display: block;
    width: 280px; 
/*    width: 100%;*/
    margin-bottom: 3px; /* Slightly reduced margin */
    font-size: 1.1em; /* Slightly smaller font */
	font-weight:bold;
  }
  #schellingCanvas { display: block; flex-grow: 1; opacity:0.8;}
  
  #startButton, #resetButton, #rulesButton {
    padding: 8px 12px; /* Slightly smaller padding */
    color: white;
    border: none;
    cursor: pointer;
    font-size: 1.1em;
    border-radius: 5px;
    text-align: center;
/*		font-weight:bold;*/
  }
  #startButton {
    background-color: #4CAF50;
  }
  #startButton:hover {
    background-color: #45a049;
  }
  #resetButton {
    background-color: #eee;
    color: #111;
  }
  #resetButton:hover {
    background-color: #ddd;
  }
  #rulesButton {
    background-color: #555;
  }
  #rulesButton:hover {
    background-color: #777;
  }

  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 5px;
    background: #d3d3d3;
    outline: none;
    -webkit-transition: .2s;
    transition: opacity .2s;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px; /* Slightly smaller thumb */
    height: 14px; /* Slightly smaller thumb */
    border-radius: 50%;
    background: #4CAF50; /* Change this color */
    cursor: pointer;
  }

  input[type="range"]::-moz-range-thumb {
    width: 14px; /* Slightly smaller thumb */
    height: 14px; /* Slightly smaller thumb */
    border-radius: 50%;
    background: #4CAF50; /* Change this color */
    cursor: pointer;
  }

  input[type="range"]:focus::-webkit-slider-thumb {
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
  }

  input[type="range"]:focus::-moz-range-thumb {
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
  }

  .popup {
    position: fixed;
    top: 30%;
    left: 30%;
	font-size:1.2em;
    transform: translate(-20%, -28%);
    background: #444;
    color: #eee;
    padding: 20px;
    border-radius: 8px;
    z-index: 10;
    display: none;
    max-width: 100%;
    max-height: 90%;
    overflow-y: auto;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  }

  .popup h2 {
    margin-top: 0;
  }

  .popup button {
    margin-top: 15px;
    padding: 8px 16px;
    background-color: #555;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 1em;
    border-radius: 5px;
  }

  .popup button:hover {
    background-color: #777;
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
/*    background: rgba(0, 0, 0, 0.5);*/
	background:#333;
    z-index: 9;
    display: none;
  }
</style>

</head>
<body>
  <div id="controls">
    <button id="rulesButton">Rules</button>
    <div>
      <label for="numbhumSlider">Size <span id="numbhumValue">150</span></label>
      <input type="range" id="numbhumSlider" min="50" max="250" value="150">

    </div>
    <div>
      <label for="wSlider">Radius <span id="wValue">4</span></label>
      <input type="range" id="wSlider" min="1" max="10" value="4">

    </div>
    <div>
      <label for="tauSlider">Tolerance <span id="tauValue">0.45</span></label>
      <input type="range" id="tauSlider" min="0.0" max="1.0" step="0.01" value="0.45">
    </div>
    <button id="startButton">Start</button>
    <button id="resetButton">Reset</button>
  </div>
  <canvas id="schellingCanvas"></canvas>

  <div id="rulesPopup" class="popup">
    <h2>Schelling's Segregation Model - Rules</h2>
    <p>This simulation models Schelling's segregation model on a 2D grid with toroidal (wrap-around) boundaries.</p>
    <h3>Agents and Preferences:</h3>
    <ul>
      <li>There are two types of agents: Red and Blue.</li>
      <li>Each agent has a tolerance level  between 0.0 and 1.0.</li>
      <li>An agent is considered "happy" if the proportion of similar neighbors within its Moore neighborhood (including the 8 adjacent cells) is greater than or equal to its tolerance. The agent itself is not counted as a neighbor.</li>
    </ul>
    <h3>Dynamics:</h3>
    <ul>
      <li>The simulation iterates through the grid. For each agent:</li>
      <li>It counts the number of similar and dissimilar neighbors within its Moore neighborhood.</li>
      <li>If the proportion of similar neighbors is less than the agent's tolerance, the agent is considered "unhappy".</li>
      <li>Unhappy agents are moved to a randomly chosen empty location on the grid.</li>
      <li>This process continues until a stable state where no agents are unhappy, or a maximum number of iterations is reached.</li>
    </ul>
    <h3>Parameters:</h3>
    <ul>
      <li><strong>Size:</strong> The dimension of the square grid.</li>
      <li><strong>Radius:</strong> Defines the extent of the neighborhood considered (Moore neighborhood, which includes all 8 adjacent cells, is used here, so this parameter doesn't directly control the radius but influences the neighbor count).</li>
      <li><strong>Tolerance:</strong> The threshold for happiness (proportion of similar neighbors).</li>
    </ul>
    <button id="closePopup">Close</button>
  </div>
  <div id="popupOverlay" class="overlay"></div>

  <script>
    // Simulation Parameters (initialized with default slider values)
    let numbhum = parseInt(document.getElementById('numbhumSlider').value);
    let w = parseInt(document.getElementById('wSlider').value);
    let tau = parseFloat(document.getElementById('tauSlider').value);
    let negsize;
    let swapmax;
    let roundrep;
    let testmode = 0;
    let seedvar;
    let r1 = 214;
    let r2 = 55;
    let r3 = 93;
    // let g1 = 203;
    // let g2 = 233;
    // let g3 = 203;
	
    let g1 = 236;
    let g2 = 250;
    let g3 = 161;
    let zoomvar = 1.0;
    let translvarx = 0;
    let translvary = 0;
    let fullScreen = false;
    let flagend = false;
    let flagstart = false;
    let roundvar = 0;
    let haltvar = 0;

    // Data Structures
    let numbhumArray = [];
    let biasArray = [];
    let unhapRed = [];
    let unhapBlue = [];
    let ijnegvec = [];
    let ijnegvecsize;
    let rednu = 0;
    let bluenu = 0;

    // Canvas and Context
    const canvas = document.getElementById('schellingCanvas');
    const ctx = canvas.getContext('2d');
    let widtha = window.innerWidth;
    let heighta = window.innerHeight;


    function utilityCount() {
      let utilr = 0;
      let utilg = 0;
      for (let i = 0; i < numbhum; i++) {
        for (let j = 0; j < numbhum; j++) {
          if (numbhumArray[i][j] === 1) {
            utilr += ((2 * w + 1) + biasArray[i][j]) / 2;
          } else {
            utilg += ((2 * w + 1) - biasArray[i][j]) / 2;
          }
        }
      }
      return utilr + utilg;
    }

    function signfs(argt) {
      if (argt < 0) {
        return numbhum + argt;
      } else if (argt >= numbhum) {
        return argt - numbhum;
      } else {
        return argt;
      }
    }

    function biasArMod(argp, argq) {
      const p = signfs(argp);
      const q = signfs(argq);
      if (p >= 0 && q >= 0) {
        return numbhumArray[p][q];
      } else {
        return 0;
      }
    }

    // Main Simulation Functions
    function updateParameters() {
      numbhum = parseInt(document.getElementById('numbhumSlider').value);
      w = parseInt(document.getElementById('wSlider').value);
      tau = parseFloat(document.getElementById('tauSlider').value);
      negsize = (2 * w + 1) * (2 * w + 1);
      tau1 = negsize * (1 - 2 * tau);
      tau0 = negsize * (2 * tau - 1);
      swapmax = 100 * numbhum * numbhum;
      roundrep = 40; // Keep this constant or make it a parameter
    }

    function resetSimulation() {
      flagstart = false;
      flagend = false;
      roundvar = 0;
      haltvar = 0;
      unhapRed = [];
      unhapBlue = [];
      updateParameters();
      buildHumans();
      buildInitBiasArr();
      ijnegvec = [];
      for (let i = 0; i < 2 * w + 1; i++) {
        for (let j = 0; j < 2 * w + 1; j++) {
          ijnegvec.push([i - w, j - w]);
        }
      }
      ijnegvecsize = ijnegvec.length;
      drawTheOutput();
      console.log("\nSimulation reset.\n");
    }

    function startAnimation() {
      if (!flagstart) {
        flagstart = true;
        animate();
        console.log("Animation started...");
      }
    }

    function buildHumans() {
      numbhumArray = Array(numbhum).fill(null).map(() => Array(numbhum));
      rednu = 0;
      bluenu = 0;
      for (let i = 0; i < numbhum; i++) {
        for (let j = 0; j < numbhum; j++) {
          if (Math.random() < 0.5) {
            numbhumArray[i][j] = -1;
            bluenu++;
          } else {
            numbhumArray[i][j] = 1;
            rednu++;
          }
        }
      }
      console.log(`Produced randomly coloured humans: ${rednu} red and ${bluenu} blue`);
    }

    function buildInitBiasArr() {
      biasArray = Array(numbhum).fill(null).map(() => Array(numbhum).fill(0));
      let biasvar = 0;
      for (let i = 0; i < 2 * w + 1; i++) {
        for (let j = 0; j < 2 * w + 1; j++) {
          biasvar += biasArMod(i - w, j - w);
        }
      }
      biasArray[0][0] = biasvar;
      if (numbhumArray[0][0] === 1 && biasArray[0][0] < tau0) {
        unhapRed.push([0, 0]);
      } else if (numbhumArray[0][0] === -1 && biasArray[0][0] > tau1) {
        unhapBlue.push([0, 0]);
      }

      for (let i = 0; i < numbhum - 1; i++) {
        let biasvarX = 0;
        let biasvarY = 0;
        for (let j = 0; j < 2 * w + 1; j++) {
          biasvarX += biasArMod(i + 1 + w, j - w);
          biasvarY += biasArMod(i - w, j - w);
        }
        biasArray[i + 1][0] = biasArray[i][0] - biasvarY + biasvarX;
        if (numbhumArray[i + 1][0] === 1 && biasArray[i + 1][0] < tau0) {
          unhapRed.push([i + 1, 0]);
        } else if (numbhumArray[i + 1][0] === -1 && biasArray[i + 1][0] > tau1) {
          unhapBlue.push([i + 1, 0]);
        }
      }

      for (let i = 0; i < numbhum; i++) {
        for (let k = 0; k < numbhum - 1; k++) {
          let biasvarX = 0;
          let biasvarY = 0;
          for (let j = 0; j < 2 * w + 1; j++) {
            biasvarX += biasArMod(i - w + j, k + 1 + w);
            biasvarY += biasArMod(i - w + j, k - w);
          }
          biasArray[i][k + 1] = biasArray[i][k] - biasvarY + biasvarX;
          if (numbhumArray[i][k + 1] === 1 && biasArray[i][k + 1] < tau0) {
            unhapRed.push([i, k + 1]);
          } else if (numbhumArray[i][k + 1] === -1 && biasArray[i][k + 1] > tau1) {
            unhapBlue.push([i, k + 1]);
          }
        }
      }
    }

    function swapTest(swapx0, swapx1, swapy0, swapy1) {
      if (biasArray[swapx0][swapx1] > biasArray[swapy0][swapy1] + 2) {
        return 0;
      } else if (
        (Math.abs(swapx0 - swapy0) <= w && Math.abs(swapx1 - swapy1) <= w) &&
        (biasArray[swapx0][swapx1] >= biasArray[swapy0][swapy1] + 2)
      ) {
        return 0;
      } else {
        return 1;
      }
    }

    function exhaustRout() {
      testmode = 1;
      let exhaustswap = 0;
      let unhapRedspec = [];
      let unhapBluespec = [];
      console.log("STARTING EXHAUSTIVE SEARCH...");
      for (let i = 0; i < unhapRed.length; i++) {
        for (let j = 0; j < unhapBlue.length; j++) {
          const swapx0 = unhapRed[i][0];
          const swapx1 = unhapRed[i][1];
          const swapy0 = unhapBlue[j][0];
		  const swapy1 = unhapBlue[j][1];
		            if (swapTest(swapx0, swapx1, swapy0, swapy1) === 1) {
		              exhaustswap++;
		              unhapRedspec.push([swapx0, swapx1]);
		              unhapBluespec.push([swapy0, swapy1]);
		            }
		          }
		        }
		        if (exhaustswap === 0) {
		          haltvar = 1;
		          console.log("...NO LEGIT SWAPS REMAINING");
		        } else {
		          haltvar = 0;
		          console.log(`FOUND ${exhaustswap} POSSIBILITIES`);
		          const x = Math.floor(Math.random() * unhapRedspec.length);
		          const swapx0 = unhapRedspec[x][0];
		          const swapx1 = unhapRedspec[x][1];
		          const swapy0 = unhapBluespec[x][0];
		          const swapy1 = unhapBluespec[x][1];
		          return { swapx0, swapx1, swapy0, swapy1, x };
		        }
		        return null;
		      }

		      function doSwapFollowConv() {
		        let swaphappened = 0;
		        let swapx0, swapx1, swapy0, swapy1, x, y;

		        if (unhapRed.length > 0 && unhapBlue.length > 0) {
		          x = Math.floor(Math.random() * unhapRed.length);
		          y = Math.floor(Math.random() * unhapBlue.length);
		          swapx0 = unhapRed[x][0];
		          swapx1 = unhapRed[x][1];
		          swapy0 = unhapBlue[y][0];
		          swapy1 = unhapBlue[y][1];
		          let roundret = 0;
		          testmode = 0;

		          while (roundret < numbhum * numbhum && tau > 0.5 && (swapTest(swapx0, swapx1, swapy0, swapy1) === 0)) {
		            x = Math.floor(Math.random() * unhapRed.length);
		            y = Math.floor(Math.random() * unhapBlue.length);
		            swapx0 = unhapRed[x][0];
		            swapx1 = unhapRed[x][1];
		            swapy0 = unhapBlue[y][0];
		            swapy1 = unhapBlue[y][1];
		            roundret++;
		          }

		          if (roundret < numbhum * numbhum) {
		            numbhumArray[swapx0][swapx1] = -1;
		            numbhumArray[swapy0][swapy1] = 1;
		            unhapRed.splice(x, 1);
		            unhapBlue.splice(y, 1);
		            swaphappened = 1;
		            return { swapx0, swapx1, swapy0, swapy1, swaphappened, x, y };
		          } else if (tau > 0.5) {
		            const exhaustResult = exhaustRout();
		            if (exhaustResult && exhaustResult.exhaustswap > 0) {
		              numbhumArray[exhaustResult.swapx0][exhaustResult.swapx1] = -1;
		              numbhumArray[exhaustResult.swapy0][exhaustResult.swapy1] = 1;
		              unhapRed.splice(exhaustResult.x, 1);
		              unhapBlue.splice(exhaustResult.y, 1);
		              swaphappened = 1;
		              return { swapx0: exhaustResult.swapx0, swapx1: exhaustResult.swapx1, swapy0: exhaustResult.swapy0, swapy1: exhaustResult.swapy1, swaphappened, x: exhaustResult.x, y: exhaustResult.y };
		            }
		          }
		        }
		        return { swaphappened: 0 };
		      }

		      function updateBiasLists(swapResult) {
		        if (!swapResult.swaphappened) return;
		        const { swapx0, swapx1, swapy0, swapy1, x, y } = swapResult;

		        for (let i = 0; i < ijnegvecsize; i++) {
		          const biasvarR0 = signfs(swapx0 + ijnegvec[i][0]);
		          const biasvarR1 = signfs(swapx1 + ijnegvec[i][1]);
		          const biasRtargOld = biasArray[biasvarR0][biasvarR1];
		          const oldRedUnhappy = unhapRed.some(item => item[0] === biasvarR0 && item[1] === biasvarR1);

		          if (
		            (Math.abs(biasvarR0 - swapy0) > w && Math.abs(biasvarR0 - swapy0) < numbhum - w) ||
		            (Math.abs(biasvarR1 - swapy1) > w && Math.abs(biasvarR1 - swapy1) < numbhum - w)
		          ) {
		            biasArray[biasvarR0][biasvarR1] -= 2;
		            if (numbhumArray[biasvarR0][biasvarR1] === 1 && biasArray[biasvarR0][biasvarR1] < tau0 && !oldRedUnhappy && biasRtargOld >= tau0) {
		              unhapRed.push([biasvarR0, biasvarR1]);
		            } else if (numbhumArray[biasvarR0][biasvarR0] === -1 && biasRtargOld > tau1 && !(biasvarR0 === swapx0 && biasvarR1 === swapx1) && biasArray[biasvarR0][biasvarR1] <= tau1) {
		              unhapBlue = unhapBlue.filter(item => !(item[0] === biasvarR0 && item[1] === biasvarR1));
		            }
		          }

		          const biasvarB0 = signfs(swapy0 + ijnegvec[i][0]);
		          const biasvarB1 = signfs(swapy1 + ijnegvec[i][1]);
		          const biasBtargOldB = biasArray[biasvarB0][biasvarB1];
		          const oldBlueUnhappy = unhapBlue.some(item => item[0] === biasvarB0 && item[1] === biasvarB1);

		          if (
		            (Math.abs(biasvarB0 - swapx0) > w && Math.abs(biasvarB0 - swapx0) < numbhum - w) ||
		            (Math.abs(biasvarB1 - swapx1) > w && Math.abs(biasvarB1 - swapx1) < numbhum - w)
		          ) {
		            biasArray[biasvarB0][biasvarB1] += 2;
		            if (numbhumArray[biasvarB0][biasvarB1] === 1 && biasBtargOldB + 2 >= tau0 && !unhapRed.some(item => item[0] === biasvarB0 && item[1] === biasvarB1) && biasBtargOldB < tau0 && !(biasvarB0 === swapy0 && biasvarB1 === swapy1)) {
		              unhapRed = unhapRed.filter(item => !(item[0] === biasvarB0 && item[1] === biasvarB1));
		            } else if (numbhumArray[biasvarB0][biasvarB1] === -1 && biasBtargOldB <= tau1 && biasBtargOldB + 2 > tau1) {
		              unhapBlue.push([biasvarB0, biasvarB1]);
		            }
		          }
		        }

		        if (biasArray[swapx0][swapx1] > tau1) {
		          unhapBlue.push([swapx0, swapx1]);
		        } else if (unhapBlue.some(item => item[0] === swapx0 && item[1] === swapx1) && biasArray[swapx0][swapx1] <= tau1) {
		          unhapBlue = unhapBlue.filter(item => !(item[0] === swapx0 && item[1] === swapx1));
		        }

		        if (biasArray[swapy0][swapy1] < tau0) {
		          unhapRed.push([swapy0, swapy1]);
		        } else if (unhapRed.some(item => item[0] === swapy0 && item[1] === swapy1) && biasArray[swapy0][swapy1] >= tau0) {
		          unhapRed = unhapRed.filter(item => !(item[0] === swapy0 && item[1] === swapy1));
		        }
		      }


		      function loopStopCondition() {
		        if (unhapRed.length === 0) {
		          // console.log(`Finished swapping after ${roundvar} swaps.\nThere are no more unhappy red humans (reason for stopping swapping).`);
		          return 0;
		        } else if (unhapBlue.length === 0) {
		          // console.log(`Finished swapping after ${roundvar} swaps.\nThere are no more unhappy blue humans (reason for stopping swapping).`);
		          return 0;
		        } else if (haltvar === 1) {
		          // console.log(`Finished swapping after ${roundvar} swaps.\nNo legitimate swaps remaining, after exhaustive search.`);
		          return 0;
		        } else {
		          return 1;
		        }
		      }

		      function animate() {
		        if (flagstart && !flagend) {
		          for (let step = 0; step < roundrep; step++) {
		            if (loopStopCondition() === 0) {
		              flagstart = false;
		              break;
		            }
		            const swapResult = doSwapFollowConv();
		            if (swapResult.swaphappened === 1) {
		              updateBiasLists(swapResult);
		              // if (roundvar % roundrep === 0) {
		              //   reportNumbSwapsCur();
		              // }
		              roundvar++;
		            }
		          }
		          drawTheOutput();
		          if (flagstart) {
		            requestAnimationFrame(animate);
		          } else {
		            // outputFinalNumbers();
		            flagend = true;
		          }
		        }
		      }

		      function drawTheOutput() {
		        canvas.width = window.innerWidth;
		        canvas.height = window.innerHeight;
		        widtha = canvas.width;
		        heighta = canvas.height;

		        const cellSize = Math.min(canvas.width / numbhum, canvas.height / numbhum) * 0.9;
		        const gridWidth = numbhum * cellSize;
		        const gridHeight = numbhum * cellSize;
		        const offsetX = (canvas.width - gridWidth) / 16;
		        const offsetY = (canvas.height - gridHeight) / 2;

		        ctx.clearRect(0, 0, canvas.width, canvas.height);

		        const overlap = 0.6; // Adjust this value if needed
		        const fillSize = cellSize + overlap;

		        for (let i = 0; i < numbhum; i++) {
		          for (let j = 0; j < numbhum; j++) {
		            ctx.fillStyle = (numbhumArray[i][j] === 1) ? `rgb(${r1}, ${r2}, ${r3})` : `rgb(${g1}, ${g2}, ${g3})`;
		            ctx.fillRect(j * cellSize + offsetX - overlap / 2, i * cellSize + offsetY - overlap / 2, fillSize, fillSize);
		          }
		        }
		      }


		      function handleKeyDown(event) {
		        switch (event.key) {
		          case 'f':
		            fullScreen = !fullScreen;
		            canvas.width = window.innerWidth;
		            canvas.height = window.innerHeight;
		            drawTheOutput();
		            break;
		          case 'q':
		            location.reload();
		            break;
		          case 'g':
		            flagstart = !flagstart;
		            if (flagstart) {
		              animate();
		            }
		            break;
		          case 'r':
		            randomCol();
		            drawTheOutput();
		            break;
		        }
		      }

		      function initialize() {
		        canvas.style.width = '100%';
		        canvas.style.height = '100%';
		        canvas.width = window.innerWidth;
		        canvas.height = window.innerHeight;

		        updateParameters();
		        buildHumans();
		        buildInitBiasArr();

		        ijnegvec = [];
		        for (let i = 0; i < 2 * w + 1; i++) {
		          for (let j = 0; j < 2 * w + 1; j++) {
		            ijnegvec.push([i - w, j - w]);
		          }
		        }
		        ijnegvecsize = ijnegvec.length;

		        window.addEventListener('resize', drawTheOutput);

		        document.getElementById('numbhumSlider').addEventListener('input', function() {
		          document.getElementById('numbhumValue').textContent = this.value;
		          updateParameters();
		          resetSimulation();
		        });
		        document.getElementById('wSlider').addEventListener('input', function() {
		          document.getElementById('wValue').textContent = this.value;
		          updateParameters();
		          resetSimulation();
		        });
		        document.getElementById('tauSlider').addEventListener('input', function() {
		          document.getElementById('tauValue').textContent = parseFloat(this.value).toFixed(2);
		          updateParameters();
		          resetSimulation();
		        });
		        document.getElementById('resetButton').addEventListener('click', resetSimulation);
		        document.getElementById('startButton').addEventListener('click', startAnimation);

		        // Rules button functionality
		        const rulesButton = document.getElementById('rulesButton');
		        const rulesPopup = document.getElementById('rulesPopup');
		        const closePopup = document.getElementById('closePopup');
		        const popupOverlay = document.getElementById('popupOverlay');

		        rulesButton.addEventListener('click', () => {
		          rulesPopup.style.display = 'block';
		          popupOverlay.style.display = 'block';
		        });

		        closePopup.addEventListener('click', () => {
		          rulesPopup.style.display = 'none';
		          popupOverlay.style.display = 'none';
		        });

		        popupOverlay.addEventListener('click', () => {
		          rulesPopup.style.display = 'none';
		          popupOverlay.style.display = 'none';
		        });


		        console.log("\nReady to start (press 'Start Animation' to begin)...\n");

		        drawTheOutput();
		      }

		      initialize();
		    </script>
		  </body>
		  </html>